{
    "contents" : "#' Get the numerical contrast vector for the dataset\n#'\n#' @param gstt an object of class DESeqDataSet \n#' @seealso \\code{DESeq2:::cleanContrast}\n#' @export\n#' @examples\n#' library(DESeq2)\n#' example(DESeq)\n#' getContrast(dds)\ngetContrast <- function(object, contrast, name) {\n  \n  ## the following code is copied from DESeq2 package\n  if (!\"results\" %in% mcols(mcols(object))$type) {\n    stop(\"results should have been computed.\")\n  }\n  \n  test <- attr(object,\"test\")\n  \n  isExpanded <- attr(object, \"modelMatrixType\") == \"expanded\"\n  termsOrder <- attr(terms.formula(design(object)),\"order\")\n  # allows use of 'name' for expanded model matrices if there are interactions\n  if ((test == \"Wald\") & isExpanded & missing(contrast) & all(termsOrder < 2)) {\n    if (missing(name)) {\n      designVars <- all.vars(design(object))\n      lastVarName <- designVars[length(designVars)]\n      lastVar <- colData(object)[[lastVarName]]\n      if (is.factor(lastVar)) {\n        nlvls <- nlevels(lastVar)\n        contrast <- c(lastVarName, levels(lastVar)[nlvls], levels(lastVar)[1])\n        cont <- getNumericFromCharContrast(object, contrast, isExpanded)\n        return(cont)\n      }\n    } else {     \n      stop(\"\\n\n              note: an expanded model matrix was used in fitting the model.\n              \n              recommendation: the 'contrast' argument should be used to extract\n              log2 fold changes of levels against each other.\\n\")\n    }\n  }\n  if (missing(name)) {\n    name <- lastCoefName(object)\n  }\n  altHypothesis <- match.arg(altHypothesis, choices=c(\"greaterAbs\",\"lessAbs\",\"greater\",\"less\"))\n  stopifnot(lfcThreshold >= 0)\n  stopifnot(length(lfcThreshold)==1)\n  stopifnot(length(altHypothesis)==1)\n  stopifnot(length(alpha)==1)\n  stopifnot(length(pAdjustMethod)==1)\n  if (length(name) != 1 | !is.character(name)) {\n    stop(\"the argument 'name' should be a character vector of length 1\")\n  }\n  if (lfcThreshold == 0 & altHypothesis == \"lessAbs\") {\n    stop(\"when testing altHypothesis='lessAbs', set the argument lfcThreshold to a positive value\")\n  }\n  \n  # check to see at least one of these are present\n  WaldResults <- paste0(\"WaldPvalue_\",name) %in% names(mcols(object))\n  LRTResults <- \"LRTPvalue\" %in% names(mcols(object))\n  if (! ( WaldResults | LRTResults) ) {\n    stop(\"cannot find appropriate results, for available names call 'resultsNames(object)'\")\n  }\n  \n  # if performing a contrast call the function cleanContrast()\n  if (!missing(contrast)) {\n    if (is.character(contrast) & length(contrast) != 3) {\n      stop(\"contrast should either be a character vector of length 3, of the form:\ncontrast = c('factorName','numeratorLevel','denominatorLevel'),\nor a numeric vector the same length as resultsNames(dds).\nsee the manual page of ?results for more information\")\n    }\n    \n    # pass down whether the model matrix type was \"expanded\"\n    cont <- getNumericFromCharContrast(object, contrast, expanded=isExpanded)\n    return(cont)\n  } else {\n    stop(\"You've uncovered a corner case! Please contact the maintainer \n         with your dataset and reproducible steps for help.\")\n  }\n  stop(\"You've uncovered a corner case! Please contact the maintainer \n         with your dataset and reproducible steps for help.\")\n}\n\n\ngetNumericFromCharContrast <- function(object, contrast, expanded) {\n  if ( missing(contrast) | !is.character(contrast) | (length(contrast)!=3) ) {\n    stop(\"should be called with a character contrast vector c('factor','level1','level2')\")\n  }\n  # check if the appropriate columns are in the resultsNames\n  if (contrast[2] == contrast[3]) {\n    stop(paste(contrast[2],\"and\",contrast[3],\"should be different level names\"))\n  }\n  colData <- colData(object)\n  cont <- rep(0, length(nrow(colData)))\n  cont(which(colData[,contrastFactor]==contrast[2])) <- 1\n  return(cont)\n  contrastFactor <- contrast[1]\n  if (!contrastFactor %in% names(colData(object))) {\n    stop(paste(contrastFactor,\"should be the name of a factor in the colData of the DESeqDataSet\"))\n  }\n  contrastNumLevel <- contrast[2]\n  contrastDenomLevel <- contrast[3]\n  \n  # case 1: standard model matrices: build the appropriate contrast\n  # coefficients names are of the form  \"factor_level_vs_baselevel\"\n  # output: contrastNumColumn and contrastDenomColumn\n  if (!expanded) {\n    \n    # then we have a base level for the factor\n    contrastBaseLevel <- levels(colData(object)[,contrastFactor])[1]\n    \n    # use make.names() so the column names are\n    # the same as created by DataFrame in mcols(object).\n    contrastNumColumn <- make.names(paste0(contrastFactor,\"_\",contrastNumLevel,\"_vs_\",contrastBaseLevel))\n    contrastDenomColumn <- make.names(paste0(contrastFactor,\"_\",contrastDenomLevel,\"_vs_\",contrastBaseLevel))\n    resNames <- resultsNames(object)\n    \n    # check in case the desired contrast is already\n    # available in mcols(object), and then we can either\n    # take it directly or multiply the log fold\n    # changes and stat by -1\n    stop(\"You've uncovered a corner case! Please contact the maintainer \n         with your dataset and reproducible steps for help.\")\n    if ( contrastDenomLevel == contrastBaseLevel ) {\n      # the results can be pulled directly from mcols(object)\n      name <- make.names(paste0(contrastFactor,\"_\",contrastNumLevel,\"_vs_\",contrastDenomLevel))\n      if (!name %in% resNames) {\n        stop(paste(\"as\",contrastDenomLevel,\"is the base level, was expecting\",name,\"to be present in 'resultsNames(object)'\"))\n      }\n      test <- \"Wald\"\n      log2FoldChange <- getCoef(object, name)\n      lfcSE <- getCoefSE(object, name)\n      stat <- getStat(object, test, name)\n      pvalue <- getPvalue(object, test, name)\n      res <- cbind(mcols(object)[\"baseMean\"],\n                   log2FoldChange,lfcSE,stat,\n                   pvalue)\n      names(res) <- c(\"baseMean\",\"log2FoldChange\",\"lfcSE\",\"stat\",\"pvalue\")\n      return(res)\n    } else if ( contrastNumLevel == contrastBaseLevel ) {\n      # fetch the results for denom vs num \n      # and mutiply the log fold change and stat by -1\n      cleanName <- paste(contrastFactor,contrastNumLevel,\"vs\",contrastDenomLevel)\n      swapName <- make.names(paste0(contrastFactor,\"_\",contrastDenomLevel,\"_vs_\",contrastNumLevel))\n      if (!swapName %in% resNames) {\n        stop(paste(\"as\",contrastNumLevel,\"is the base level, was expecting\",swapName,\"to be present in 'resultsNames(object)'\"))\n      }\n      test <- \"Wald\"\n      log2FoldChange <- getCoef(object, swapName)\n      lfcSE <- getCoefSE(object, swapName)\n      stat <- getStat(object, test, swapName)\n      pvalue <- getPvalue(object, test, swapName)\n      res <- cbind(mcols(object)[\"baseMean\"],\n                   log2FoldChange,lfcSE,stat,\n                   pvalue)\n      names(res) <- c(\"baseMean\",\"log2FoldChange\",\"lfcSE\",\"stat\",\"pvalue\")\n      res$log2FoldChange <- -1 * res$log2FoldChange\n      res$stat <- -1 * res$stat\n      # also need to swap the name in the mcols\n      contrastDescriptions <- paste(c(\"log2 fold change (MAP):\",\n                                      \"standard error:\",\n                                      \"Wald statistic:\",\n                                      \"Wald test p-value:\"),\n                                    cleanName)\n      mcols(res)$description[mcols(res)$type == \"results\"] <- contrastDescriptions\n      return(res)\n    }\n    \n    # check for the case where neither are present\n    # as comparisons against base level\n    if ( ! (contrastNumColumn %in% resNames &\n              contrastDenomColumn %in% resNames) ) {\n      stop(paste(contrastNumLevel,\"and\",contrastDenomLevel,\"should be levels of\",contrastFactor,\n                 \"such that\",contrastNumColumn,\"and\",contrastDenomColumn,\n                 \"are contained in 'resultsNames(object)'\"))\n    }\n    \n    # case 2: expanded model matrices: build the appropriate contrasrt\n    # these coefficient names have the form \"factorlevel\"\n    # output: contrastNumColumn and contrastDenomColumn\n  } else {\n    \n    # else in the expanded case, we first check validity\n    contrastNumColumn <- make.names(paste0(contrastFactor, contrastNumLevel))\n    contrastDenomColumn <- make.names(paste0(contrastFactor, contrastDenomLevel))\n    if ( ! (contrastNumColumn %in% resNames & contrastDenomColumn %in% resNames) ) {\n      stop(paste(\"both\",contrastNumLevel,\"and\",contrastDenomLevel,\"are expected to be in\nresultsNames(object), prefixed by\",contrastFactor))\n    }\n  }\n  stop(\"You've uncovered a corner case! Please contact the maintainer \n         with your dataset and reproducible steps for help.\")\n}\n",
    "created" : 1402024190568.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1661521064",
    "id" : "19521072",
    "lastKnownWriteTime" : 1402034353,
    "path" : "~/work/GSTT/R/contrasts.r",
    "project_path" : "R/contrasts.r",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}